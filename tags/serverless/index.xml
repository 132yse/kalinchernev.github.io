<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Serverless on Kalin Chernev</title>
    <link>https://kalinchernev.github.io/tags/serverless/index.xml</link>
    <description>Recent content in Serverless on Kalin Chernev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="https://kalinchernev.github.io/tags/serverless/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Test-Driven Development for AWS Lambda functions with the Serverless framework and Jest</title>
      <link>https://kalinchernev.github.io/tdd-serverless-jest/</link>
      <pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kalinchernev.github.io/tdd-serverless-jest/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://serverless.com/&#34;&gt;serverless framework&lt;/a&gt; makes it easy to develop and deploy cloud functions. In this article I&amp;rsquo;ll cover the &lt;a href=&#34;https://serverless.com/framework/docs/providers/aws/&#34;&gt;AWS&lt;/a&gt; provider of the framework, although the principles should be very similar for the other providers, especially given the fact the serverless team works hard for a truly multi-provider framework.&lt;/p&gt;

&lt;p&gt;There is a good document with guidelines for &lt;a href=&#34;https://serverless.com/framework/docs/providers/aws/guide/testing/&#34;&gt;writing tests in serverless&lt;/a&gt; already. Also, there is another &lt;a href=&#34;https://serverless.com/blog/tdd-serverless/&#34;&gt;blog post about the basics&lt;/a&gt;. However, currently there&amp;rsquo;s no much information on using &lt;a href=&#34;https://facebook.github.io/jest/&#34;&gt;Jest&lt;/a&gt; which is trending in the community.&lt;/p&gt;

&lt;p&gt;By the end of this article, you will:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;have a working development environment with modern JavaScript (ES2005 and up)&lt;/li&gt;
&lt;li&gt;be able to use Jest effectively&lt;/li&gt;
&lt;li&gt;know how to test your library code - the helpers used by lambda functions&lt;/li&gt;
&lt;li&gt;be able to test lambda functions without killing yourself with abstractions&lt;/li&gt;
&lt;li&gt;learn how to use test doubles for AWS services&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;project-setup&#34;&gt;Project setup&lt;/h2&gt;

&lt;p&gt;Before going into the testing framework and the details about the testing itself, it&amp;rsquo;s worth spending some time configuring your environment so that you work effectively.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a high-level overview of the file structure for the tutorial:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── config.example.json --&amp;gt; Copy and configure as config.json
├── package.json
├── README.md
├── serverless.yml --&amp;gt; Check if you want to tweak it
├── src --&amp;gt; You store your functions here, 1 file per each
│   └── upload.js --&amp;gt; the lambda function
├── test
│   └── upload.spec.js --&amp;gt; the test for the lambda function
├── webpack.config.js
└── yarn.lock
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full code for the tutorial can be seen in &lt;a href=&#34;https://github.com/kalinchernev/aws-node-signed-uploads&#34;&gt;this repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tools&#34;&gt;Tools&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a list of the package used in this tutorial:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;serverless&lt;/code&gt; with &lt;code&gt;webpack&lt;/code&gt; and &lt;code&gt;serverless-webpack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;babel&lt;/code&gt; with some add-ons, mainly &lt;code&gt;babel-preset-env&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eslint&lt;/code&gt; with more add-ons, and &lt;code&gt;prettier&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aws-sdk&lt;/code&gt; and &lt;code&gt;aws-sdk-mock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jest&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;optimizations&#34;&gt;Optimizations&lt;/h3&gt;

&lt;p&gt;Although this topic is not directly related to writing tests, it&amp;rsquo;s always good to consider any possible optimizations you can have in your stack.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;babel-preset-env&lt;/code&gt; with its &lt;code&gt;babel-*&lt;/code&gt; related packages. By using the &lt;code&gt;env&lt;/code&gt; &lt;a href=&#34;http://babeljs.io/env&#34;&gt;preset&lt;/a&gt; you both gain in less configurations and less amount of code necessary after transpilations for a given target runtime platform. For example, delivering a bundle targeting &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/programming-model.html&#34;&gt;node 6.x&lt;/a&gt; will be lighter than the one for earlier versions, because the runtime supports more features natively.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;serverless-webpack&lt;/code&gt; with its webpack settings can further optimize functions when they are &lt;a href=&#34;https://github.com/serverless-heaven/serverless-webpack#optimization--individual-packaging-per-function&#34;&gt;bundled individually&lt;/a&gt;. Also, a configuration for external resources make the bundled upload lighter, excluding dependencies to &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/current-supported-versions.html&#34;&gt;&lt;code&gt;aws-sdk&lt;/code&gt; already available&lt;/a&gt; on AWS premises.&lt;/p&gt;

&lt;h3 id=&#34;configurations&#34;&gt;Configurations&lt;/h3&gt;

&lt;p&gt;In the example project linked to this article you can have a look at the configurations necessary to have modern JavaScript running with serverless and Jest.&lt;/p&gt;

&lt;h2 id=&#34;jest&#34;&gt;Jest&lt;/h2&gt;

&lt;p&gt;To learn about the test framework, read the official &lt;a href=&#34;https://facebook.github.io/jest/&#34;&gt;documentation site&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My high-level impressions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Working with promises is natural.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s the watch mode.&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s also an integrated code coverage reporting.&lt;/li&gt;
&lt;li&gt;Snapshot testing for comparing and asserting differences in structures.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, Jest is a full-fledged framework with all necessary features for testing. It&amp;rsquo;s easy to learn and it has good documentation.&lt;/p&gt;

&lt;h2 id=&#34;unit-testing&#34;&gt;Unit testing&lt;/h2&gt;

&lt;p&gt;Organizing code in &lt;a href=&#34;https://claudiajs.com/tutorials/designing-testable-lambdas.html&#34;&gt;testable chunks&lt;/a&gt; is the the most challenging and important step before anything else.&lt;/p&gt;

&lt;p&gt;In the context of lambda functions and the serverless framework, unit testing is useful for covering mainly 2 types of code: library (helper) functions and the lambda functions in a given service. If you&amp;rsquo;re using the serverless framework only with &lt;code&gt;serverless.yml&lt;/code&gt; file in order to make your Cloud Formation templates more manageable, you don&amp;rsquo;t need unit testing. It&amp;rsquo;s only uesful when there is logic in the service.&lt;/p&gt;

&lt;h2 id=&#34;testing-a-library-used-by-a-lambda-function&#34;&gt;Testing a library used by a lambda function&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s imagine that our lambda function signature and beginning is the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const handler = (event, context, callback) =&amp;gt; {
  const bucket = process.env.BUCKET;
  const region = process.env.REGION;

  ...

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we will most probably need to make checks about the input arguments of environment variables several times, we can make a &lt;a href=&#34;https://github.com/kalinchernev/aws-node-signed-uploads/blob/master/src/lib/envVarsChecker.js&#34;&gt;simple helper&lt;/a&gt; which takes an object of the &lt;code&gt;process.env&lt;/code&gt; and returns a list of required keys for the function to work.&lt;/p&gt;

&lt;p&gt;This scenario is easy, we can assert for various of useful edge cases like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import checker from &#39;../../src/lib/envVarsChecker&#39;;

describe(`Utility library envVarsChecker`, () =&amp;gt; {
  test(`The helper exists`, () =&amp;gt; {
    expect(checker).toBeTruthy();
  });

  test(`Asks for both BUCKET and REGION environment variables`, () =&amp;gt; {
    const input = {};
    const result = checker(input);
    expect(result).toEqual([&#39;BUCKET&#39;, &#39;REGION&#39;]);
  });

  test(`Asks for a missing BUCKET environment variables`, () =&amp;gt; {
    const input = {
      REGION: &#39;foo&#39;,
    };
    const result = checker(input);
    expect(result).toEqual([&#39;BUCKET&#39;]);
  });

  test(`Asks for a missing REGION environment variables`, () =&amp;gt; {
    const input = {
      BUCKET: &#39;foo&#39;,
    };
    const result = checker(input);
    expect(result).toEqual([&#39;REGION&#39;]);
  });
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When functions are simple, but yet reusable for several lambda functions, we can test these helpers in a conventional way.&lt;/p&gt;

&lt;h2 id=&#34;testing-a-lambda-function&#34;&gt;Testing a lambda function&lt;/h2&gt;

&lt;p&gt;The lambda functions can be considered as a more complex piece of code to test.&lt;/p&gt;

&lt;p&gt;Initially, I started by spawning processes and running the serverless CLI and asserting for results. This didn&amp;rsquo;t work efficiently because every unresolved promise in the serverless framework abstraction is impossible to handle in a convenient way in the test suite.&lt;/p&gt;

&lt;p&gt;Since the original process of the lambda function was not easy to get done with, I also tried the &lt;code&gt;serverless-jest-plugin&lt;/code&gt; which was mentioned in the beginners article about TDD in serverless. As I already knew it&amp;rsquo;s ineffective to test against cli processes, I used the plugin programmatically to wrap the original lambda functions invocation. This also didn&amp;rsquo;t work well enough.&lt;/p&gt;

&lt;p&gt;In the end of a long day I finally decided to treat lambda functions as normal functions and just wrap them in promises in order to make them more convenient for the Jest runner.&lt;/p&gt;

&lt;p&gt;Like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import { promisify } from &amp;quot;util&amp;quot;;
import lambda from &amp;quot;../src/upload&amp;quot;;
const handler = promisify(lambda);

describe(`Service aws-node-singned-uploads`, () =&amp;gt; {
  test(`Require environment variables`, () =&amp;gt; {
    const event = {};
    const context = {};

    const result = handler(event, context);
    result
      .then(data =&amp;gt; {
        expect(data).toBeFalsy();
      })
      .catch(e =&amp;gt; {
        expect(e).toBe(
          `Missing required environment variables: BUCKET, REGION`
        );
      });
  });
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach does the job ok and keeps things relatively simple. It handles the lambda handler as a normal exported function which takes the arguments as described in the official signature of the function, and wraps it all in a promise, for Jest.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://facebook.github.io/jest/docs/en/asynchronous.html#resolves-rejects&#34;&gt;syntax of promise assertions&lt;/a&gt; can be prettier, by the way.&lt;/p&gt;

&lt;h2 id=&#34;mocking-aws-services&#34;&gt;Mocking AWS services&lt;/h2&gt;

&lt;p&gt;Testing lambda functions with the assumption that they are just functions can take you long way if the logic inside these functions is relatively simple. However, the real reason for lambda functions to be, is that they are the glue between AWS services.&lt;/p&gt;

&lt;p&gt;So, sooner or later you will have to find a way to mock AWS services in your tests :)&lt;/p&gt;

&lt;p&gt;For us, the &lt;code&gt;aws-sdk-mock&lt;/code&gt; package works well so far. It supports mocking constructors and nested methods, it can restore originals. &lt;a href=&#34;https://www.npmjs.com/package/aws-sdk-mock&#34;&gt;Documentation&lt;/a&gt; and support seem mature.&lt;/p&gt;

&lt;p&gt;Together with mocking AWS services, we also take &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/eventsources.html&#34;&gt;examples for events from the official AWS documentation&lt;/a&gt;. These can serve as a fast-track to creating stubs for the &lt;code&gt;event&lt;/code&gt; argument of a lambda function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
import AWS from &amp;quot;aws-sdk-mock&amp;quot;;
import { promisify } from &amp;quot;util&amp;quot;;
import lambda from &amp;quot;../src/upload&amp;quot;;
import eventStub from &amp;quot;./stubs/eventHttpApiGateway.json&amp;quot;;

const handler = promisify(lambda);

describe(`Service aws-node-singned-uploads: S3 mock for successful operations`, () =&amp;gt; {
  beforeAll(() =&amp;gt; {
    AWS.mock(&amp;quot;S3&amp;quot;, &amp;quot;getSignedUrl&amp;quot;, (method, _, callback) =&amp;gt; {
      callback(null, {
        data: &amp;quot;https://example.com&amp;quot;
      });
    });
  });

  afterEach(() =&amp;gt; {
    delete process.env.BUCKET;
    delete process.env.REGION;
  });

  afterAll(() =&amp;gt; {
    AWS.restore(&amp;quot;S3&amp;quot;);
  });

  test(`Replies back with a JSON for a signed upload on success`, () =&amp;gt; {
    process.env.BUCKET = &amp;quot;foo&amp;quot;;
    process.env.REGION = &amp;quot;bar&amp;quot;;

    const event = eventStub;
    const context = {};

    const result = handler(event, context);
    expect(result).resolves.toMatchSnapshot();
  });
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the &lt;code&gt;beforeAll&lt;/code&gt; life cycle setups the AWS S3 mock for the &lt;code&gt;getSignedUrl&lt;/code&gt; method. &lt;code&gt;afterEach&lt;/code&gt; environment variables are reset and &lt;code&gt;afterAll&lt;/code&gt; the original S3 service is restored so that it operates to the AWS API after the test suite has finished.&lt;/p&gt;

&lt;h2 id=&#34;snapshot-testing&#34;&gt;Snapshot testing&lt;/h2&gt;

&lt;p&gt;Maybe you&amp;rsquo;ve noticed this line already &lt;code&gt;expect(result).resolves.toMatchSnapshot();&lt;/code&gt;.
This is how you use the Jest snapshot feature:&lt;/p&gt;

&lt;iframe width=&#34;853&#34; height=&#34;480&#34; src=&#34;https://www.youtube.com/embed/HAuXJVI_bUs?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;This feature helps you test structures in a simple way.&lt;/p&gt;

&lt;h3 id=&#34;further-resources&#34;&gt;Further resources&lt;/h3&gt;

&lt;p&gt;This tutorial covers mostly techniques with Jest on making unit tests. As you can see, to an extend we can say that testing lambda functions can be seen as a &lt;a href=&#34;https://read.acloud.guru/testing-and-the-serverless-approach-495cef7495ea&#34;&gt;simple&lt;/a&gt; process.&lt;/p&gt;

&lt;p&gt;However, mocking AWS services can get tricky and there are vocal opinions &lt;a href=&#34;http://theburningmonk.com/2017/02/yubls-road-to-serverless-architecture-part-2/&#34;&gt;against&lt;/a&gt; this practice for a reason.&lt;/p&gt;

&lt;p&gt;More specifically, take the &lt;a href=&#34;https://github.com/kalinchernev/aws-node-signed-uploads&#34;&gt;aws-node-signed-uploads&lt;/a&gt; package as an example. The unit tests and the mocks are showing 100% test coverage for the code which gets executed by Jest and this is really encouraging.&lt;/p&gt;

&lt;p&gt;Do the following for me as an exercise after this tutorial:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clone the repository.&lt;/li&gt;
&lt;li&gt;Install the dependencies.&lt;/li&gt;
&lt;li&gt;Reconfigure the serverless settings.&lt;/li&gt;
&lt;li&gt;Make a deployment to your AWS account.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;yarn start&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You will see a server running and waiting for your requests. You can make an example request with &lt;a href=&#34;https://www.getpostman.com/&#34;&gt;Postman&lt;/a&gt; which will show you the same issues as tested in the unit tests :)
And if you manage to get your header key correctly, you&amp;rsquo;ll be even able to upload a large file to an S3 bucket.&lt;/p&gt;

&lt;p&gt;Now make the same test on the deployed service. You will get an error message for access denied because there is a specific configuration on the upload endpoint:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;functions:
  upsert-objects:
    handler: src/upload.handler
    name: ${self:provider.stage}-${self:service}-upload
    memorySize: 128
    events:
      - http:
          path: upload
          method: put
          private: true
          cors: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is &lt;code&gt;private: true&lt;/code&gt;. When deployed on real AWS premises, the endpoint will require an API key in the header, which neither &lt;code&gt;serverless&lt;/code&gt; nor &lt;code&gt;serverless-offline&lt;/code&gt;, nor tests will warn you about.&lt;/p&gt;

&lt;p&gt;Mocking AWS services however, will give you the basic safely net that your lambda functions are handling positive and negative scenarios and invoke the correct callbacks in the correct scenarios.&lt;/p&gt;

&lt;p&gt;Also, using Jest for testing the independent logic and making snapshot make an excellent addition to secure the very vital behaviors of your cloud functions even when working independently from the AWS service.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serverless github bot with AWS Lambda and API Gateway </title>
      <link>https://kalinchernev.github.io/serverless-github-bot-aws-lambda-api-gateway-nodejs/</link>
      <pubDate>Tue, 11 Jul 2017 22:40:00 +0000</pubDate>
      
      <guid>https://kalinchernev.github.io/serverless-github-bot-aws-lambda-api-gateway-nodejs/</guid>
      <description>

&lt;p&gt;This tutorial will show you how to build a small github bot app which is &amp;ldquo;listening&amp;rdquo; for pull requests&amp;rsquo; events on &amp;ldquo;open&amp;rdquo; and &amp;ldquo;reopen&amp;rdquo; by &lt;a href=&#34;https://greenkeeper.io/&#34;&gt;greenkeeper.io&lt;/a&gt;. When the author is the greenkeeper bot, our bot will in turn, correct the title and the tags of the pull request to match conventions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/github_bot_correcting_greenkeeper-1.png&#34; alt=&#34;Github bot correcting the greenkeeper bot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve come to this article because you already have knowledge about the technical topics, but you are more interested in the concrete steps, you can skip the following introductory parts and go directly to the technical specifics below. To go to the technical details scroll down to the &lt;strong&gt;&amp;ldquo;10 steps to make it happen&amp;rdquo;&lt;/strong&gt; section ;)&lt;/p&gt;

&lt;p&gt;The script will actually be pretty small and simple, though there are quite some interesting ideas you might get on the way.&lt;/p&gt;

&lt;h2 id=&#34;serverless&#34;&gt;Serverless&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Serverless_computing&#34;&gt;Serverless computing&lt;/a&gt; is a relatively new trend which is getting greater popularity after Amazon released their &lt;a href=&#34;https://aws.amazon.com/lambda/&#34;&gt;AWS Lambda&lt;/a&gt; service in the end of 2014. I published about this topic in a bit &lt;a href=&#34;https://kalinchernev.github.io/january-digest-2017/#cloud&#34;&gt;more details earlier this year&lt;/a&gt;. In one sentence, serverless architectures (aka cloud functions) are getting traction in cases where high-level architecture control is sufficient for developers who delegate the details about the infrastructure management to a hidden underlying layer managed by a cloud provider.&lt;/p&gt;

&lt;p&gt;In addition to the low maintenance efforts, pricing per resource is also a lucrative opportunity for app developers - at the moment 1 million requests to AWS Lambda are &lt;a href=&#34;https://aws.amazon.com/free/&#34;&gt;free&lt;/a&gt; - this is generous! Later, &lt;a href=&#34;https://aws.amazon.com/lambda/pricing/&#34;&gt;pricing&lt;/a&gt; continues to be calculated based on actual usage. This means that applications cost money when they actually compute. That&amp;rsquo;s good for both up-scaling and down-scaling.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a graphic from &lt;a href=&#34;https://acloud.guru/&#34;&gt;acloud.guru&lt;/a&gt; which explains this evolution step in simple terms, I think:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/11/brief-history-of-cloud-acloud-guru.png&#34; alt=&#34;Where is the serverless in the history of the cloud&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lastly, cloud functions such as AWS Lambda come well into play in event-oriented designs. Here&amp;rsquo;s a simplified list of some &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/use-cases.html&#34;&gt;official use cases&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;event-driven services where the cloud function is run in response to other events - usually triggered by AWS S3, SNS, DynamoDB, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;services responding to HTTP requests - triggered by Amazon API Gateway or other AWS clients.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A github bot app can be considered as a service from the second set of scenarios. The end result is an API endpoint responding to &lt;code&gt;POST&lt;/code&gt; requests (events) from &lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;github webhooks&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;notes-on-the-aws-serverless-stack&#34;&gt;Notes on the AWS serverless stack&lt;/h2&gt;

&lt;p&gt;Watching videos and reading tutorials on the topic can get you pretty excited. Here are some notes about steps which didn&amp;rsquo;t go totally smooth during my journey, i.e. I want to prepare you for the reality before you get frustrated ;)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) The AWS services ain&amp;rsquo;t that easy, especially if you&amp;rsquo;re relatively new to AWS in overall&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/documentation/lambda/&#34;&gt;AWS Lambda developer guide&lt;/a&gt; - 300+ pages&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/documentation/apigateway/&#34;&gt;Amazon API Gateway developer guide&lt;/a&gt; - 450+ pages&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/documentation/iam/&#34;&gt;IAM documentation&lt;/a&gt; - I don&amp;rsquo;t even want to check &amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short - there&amp;rsquo;s a lot of information and you have to find your way through the important parts which will help you in the specific case.&lt;/p&gt;

&lt;p&gt;For our case in this tutorial, let&amp;rsquo;s assume we can follow the getting started guide and build a simple cloud function working behind an &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&#34;&gt;API gateway endpoint&lt;/a&gt;. If you want to do it right, you will have to have an idea about concepts such as: &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html&#34;&gt;mapping request and response data&lt;/a&gt;, getting to know some new &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&#34;&gt;template language for mapping variables&lt;/a&gt;, etc. These are the basics of API Gateway to get you going with the request and response management. Then come some fundamentals you&amp;rsquo;ll need about the AWS Lambda too - knowing what is a &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html&#34;&gt;handler function&lt;/a&gt; (the cloud function), figure &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html&#34;&gt;the parameters of the handler&lt;/a&gt; and &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-logging.html&#34;&gt;reading logs&lt;/a&gt; from another AWS service.&lt;/p&gt;

&lt;p&gt;In short, &amp;ldquo;keep calm and learn AWS services&amp;rdquo;, at least the basics.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) We speak cloud abstraction here - it is not easily reproducible for local development&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I spent quite some time researching on ways to have the whole AWS API Gateway + AWS Lambda setup locally so that I can start hacking quickly on my computer, but I haven&amp;rsquo;t found anything so far. If you have one or some in mind - please tell me!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) We still write JavaScript and Node.js - be ready for the regular hurdles you&amp;rsquo;ll normally have&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The fact that you&amp;rsquo;re delegating the infrastructure complexity to someone else out there doesn&amp;rsquo;t mean that your code will automagically work, at least not in the Node.js world, not at the moment.&lt;/p&gt;

&lt;p&gt;For example, sometimes you would receive errors &lt;a href=&#34;https://forums.aws.amazon.com/thread.jspa?threadID=229528&#34;&gt;like this&lt;/a&gt; and you will have to apply your JavaScript knowledge and patience to switch between versions of Node, transpile the code for the Lambda to be able to show you useful error messages &amp;hellip;&lt;/p&gt;

&lt;p&gt;For me, the &lt;a href=&#34;https://serverless.com/&#34;&gt;serverless&lt;/a&gt; framework worked pretty well in the deployment part. It definitely hid most of the complexity of understanding template languages and setting up boilerplate code for the function to work.&lt;/p&gt;

&lt;h2 id=&#34;notes-on-the-serverless-https-serverless-com-framework&#34;&gt;Notes on the &lt;a href=&#34;https://serverless.com/&#34;&gt;serverless&lt;/a&gt; framework&lt;/h2&gt;

&lt;p&gt;If you, like me, feel that the setup of the framework is a bit too much, then just go directly to the &lt;a href=&#34;https://github.com/serverless/examples&#34;&gt;example repository&lt;/a&gt; and get to know the &lt;a href=&#34;https://github.com/serverless/examples/tree/master/aws-node-github-webhook-listener&#34;&gt;aws-node-github-webhook-listener&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;By using this example boilerplate, you will need only 2 keys auth components to make the communication between services work:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/&#34;&gt;Github user token&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html&#34;&gt;AWS user tokens&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Try to keep the scope of permissions to a minimum to ensure best security in your applications. Both AWS and serverless provide other authentication options you might feel more comfortable with.&lt;/p&gt;

&lt;h2 id=&#34;notes-on-the-github-part&#34;&gt;Notes on the github part&lt;/h2&gt;

&lt;p&gt;The setup on github is simpler than AWS. Basically, you&amp;rsquo;ll need to read about &lt;a href=&#34;https://developer.github.com/webhooks/&#34;&gt;webhooks&lt;/a&gt;. The documentation is without a doubt - great - it walks you through all the stages from setting up a local dev environment, testing a hook, and also having a good knowledge of the structure of the webhooks&amp;rsquo; payloads.&lt;/p&gt;

&lt;p&gt;This is a high-level action plan:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Have an account, a repo, etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a user token. (&lt;a href=&#34;https://help.github.com/articles/differences-between-user-and-organization-accounts/&#34;&gt;user can be a bot&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Setup webhooks for a repository.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Enter information about the API Gateway endpoint which works with the cloud function, this is your bot.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-steps-to-make-it-happen&#34;&gt;10 steps to make it happen&lt;/h2&gt;

&lt;p&gt;Ok, enough introductory talks, that&amp;rsquo;s the more visual part of the article containing the main milestones making the things actually work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Create a user that can work with AWS Lambda and API Gateway services.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/create_aws_user_lambda.gif&#34; alt=&#34;Creating an AWS user you can operate with&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For simplicity, I&amp;rsquo;m adding the user to the group of admins. Then I&amp;rsquo;m downloading the tokens for later use with the serverless framework.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Go to your github profile settings page and &lt;a href=&#34;https://github.com/settings/tokens/new&#34;&gt;generate a user token&lt;/a&gt; by which the bot will act on your behalf.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can make a cool bot separate from your account, of course.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/new_user_token_github.png&#34; alt=&#34;Creating a new user token on github.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When you save this form, you will see the token, which you have to save somewhere with the same attention you would have to your password:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. &lt;a href=&#34;https://developer.github.com/webhooks/securing&#34;&gt;Generate a webhook secret&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/generate_webhook_secret-1.png&#34; alt=&#34;Generating a webhook on github.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Input the user token and the webhook secret in the serverless config file&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/save_config.png&#34; alt=&#34;Saving configurations in the serverless framework config file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. Put function code in the &lt;code&gt;handler.js&lt;/code&gt; file&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/handler.png&#34; alt=&#34;Editing the cloud function&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. You can try to deploy the function:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ serverless deploy

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watch it fail ;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/enter_credentials_serverless.png&#34; alt=&#34;Failing deployment in the serverless framework&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. Export your keys (which you downloaded in the &lt;code&gt;credentials.csv&lt;/code&gt; files earlier as:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export AWS_ACCESS_KEY_ID=
$ export AWS_SECRET_ACCESS_KEY=
# AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are now available for serverless to use
serverless deploy

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;8. Run &lt;code&gt;serverless deploy&lt;/code&gt; again and watch it succeeding&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/serverless_deploy_success.gif&#34; alt=&#34;Showing a successful deployment of a function on AWS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. Take the provided URL and add it to the webhooks of your repository where you want the bot to take effect&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kalinchernev.github.io/uploads/2017/07/12/adding_webhook_github.png&#34; alt=&#34;Adding a new webhook on github.com&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Few notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;This is the secret you previously generated via the command line&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a good practice to filter only the necessary events in order to minimize the load to the endpoint&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;10. Trigger the webhook either by github or by closing and re-opening an existing pull request which has been opened by greenkeeper bot.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s an example script you can use:
&lt;script src=&#34;https://gist.github.com/kalinchernev/d1e79a7f883a4d37f50519d9b05df0c5.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;extras&#34;&gt;Extras&lt;/h2&gt;

&lt;p&gt;When you have this automated corrections on pull request titles and tags, you might also need to &lt;a href=&#34;https://github.com/greenkeeperio/greenkeeper-lockfile&#34;&gt;update the lock files&lt;/a&gt; of the pull request to make all ready for merging.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>